#!/bin/sh
# PCP QA Test No. 2001
# Test the pcp2json filtering command
#
# Copyright (c) 2017 Red Hat, Inc.  All Rights Reserved.
#

seq=`basename $0`
echo "QA output created by $seq"
orig_dir=`pwd`

# get standard environment, filters and checks
. ./common.product
. ./common.filter
. ./common.check
. ./common.python

python_path=`which $python`
pmda_path="$PCP_PMDAS_DIR/json"
pmda_script="${pmda_path}/pmdajson.python"
pmda_config="${pmda_path}/config.json"
qa_dir=`pwd`
pmda_config_dir="${PCP_VAR_DIR}/config/pmda"
pmda_saved_config_dir="${pmda_config_dir}/pmdajson.$seq"

PCP_TMP_DIR=${tmp}
jsondata="${tmp}/json"
pmlogger="${tmp}/pmlogger"
pmlogger_conf="${pmlogger}.conf"
pmlogger_log="${pmlogger}.log"
archive="${tmp}/archive"

# test for-some-thing || _notrun No support for some-thing
test -f "$pmda_script" || _notrun "pmdajson not installed"
$python -c "from pcp import pmda" >/dev/null 2>&1
[ $? -eq 0 ] || _notrun "python pcp pmda module not installed"
$python -c "import jsonpointer" >/dev/null 2>&1
[ $? -eq 0 ] || _notrun "python jsonpointer module not installed"
$python -c "import six" >/dev/null 2>&1
[ $? -eq 0 ] || _notrun "python six module not installed"

_filter()
{
    sed \
        -e '/Performance metrics from host /s/ host .*/ host .../' \
	-e '/commencing/d' \
	-e '/ending/d' \
	-e '/^\[[0-9]* bytes]/d' \
	-e '/inst /{
s/inst \[[0-9]* or \"[^\"]*\"]/inst \[INTEGER or STRING]/
}' \
	-e '/value /{
s/value [0-9][0-9]*/value INTEGER/
}' \
	-e '/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]/s/[^ ]*/TIMESTAMP/' \
	-e "/\"$logger_pid\"/s/$logger_pid/LOGGER_PID/g" \
	-e '/pmcd.pmlogger.port/s/value .*/value PORT/' \
	-e '/pmcd.pmlogger.host/s/value ".*/value "HOST"/' \
	-e '/pmcd.pmlogger.archive/s/value ".*/value "PATH"/' \
    | $PCP_AWK_PROG '
$1 == "TIMESTAMP" && NF == 4	{ print "TIMESTAMP       0       OFFSET       OFFSET"; next }
				{ print }' \
    | src/hex2nbo
}

pmdajson_remove()
{
    echo
    echo "=== remove json agent ==="
    cd $PCP_PMDAS_DIR/json
    $sudo ./Remove >$tmp.out 2>&1
    _filter_pmda_remove <$tmp.out
    cd ${orig_dir}
}

pmdajson_install()
{
    # start from known starting points
    cd $PCP_PMDAS_DIR/json
    $sudo ./Remove >/dev/null 2>&1

    echo
    echo "=== json agent installation ==="
    $sudo ./Install </dev/null >$tmp.out 2>&1
    cat $tmp.out >>$here/$seq.full
    # Check json metrics have appeared ... X metrics and Y values
    _filter_pmda_install <$tmp.out \
    | sed \
        -e '/^Waiting for pmcd/s/\.\.\.[. ]*$/DOTS/' \
        -e 's/[0-9][0-9]* warnings, //' \
    | $PCP_AWK_PROG '
/Check json metrics have appeared/    { if ($7 >= 20 && $7 <= 80) $7 = "X"
                                        if ($10 >= 0 && $10 <= 80) $10 = "Y"
                                      }
                                      { print }'
    cd ${orig_dir}
}

_cleanup()
{
    cd $here
    if $_needclean; then
	_needclean=false
        _restore_config $PCP_PMCDCONF_PATH
	if [ -f ${pmda_config}.$seq ]; then
	    _restore_config ${pmda_config}
	fi

	# Remove the newly created indom cache files and restore any
	# old indom cache files.
	$sudo rm -f ${pmda_config_dir}/${domain}.*
	if [ -d ${pmda_saved_config_dir} ]; then
	    $sudo mv ${pmda_saved_config_dir}/* ${pmda_config_dir}/
	    $sudo rm -rf ${pmda_saved_config_dir}
	fi
	if [ -n "$pmpred_cpu_pid" ]; then
	    kill -TERM $pmpred_cpu_pid
	fi
	if [ -n "$pmpred_disk_pid" ]; then
	    kill -TERM $pmpred_disk_pid
	fi
	if [ -e ${tmp}/dd.pid ]; then
	    disk_load_pid=`cat ${tmp}/dd.pid`
	    $sudo kill -TERM $disk_load_pid
	fi
	if [ -n "$cpu_load_pid" ]; then
	    kill -TERM $cpu_load_pid
	fi
	if [ -n "$loger_pid" ]; then
	    kill -TERM $logger_pid
	fi
    fi
    $sudo rm -rf $tmp $tmp.*
}
trap "_cleanup; exit \$status" 0 1 2 3 15

status=1	# failure is the default!
$sudo rm -rf $tmp $tmp.*
mkdir $tmp
chmod ugo+rwx $tmp
cd $tmp
mkdir ${jsondata}
chmod ugo+rwx ${jsondata}

_needclean=true

domain=137
test="$here/json"

# Copy the pmcd config file to restore state later.
_save_config $PCP_PMCDCONF_PATH

# Ditto for JSON pmda config.
if [ -f ${pmda_config} ]; then
    _save_config ${pmda_config}
fi

# We want to get any JSON pmda indom cache files out of the way, so we
# start with a clean slate. We'll restore these at the end.
if [ -f "${pmda_config_dir}/${domain}.0" ]; then
    $sudo rm -rf ${pmda_saved_config_dir}
    $sudo mkdir ${pmda_saved_config_dir}
    $sudo mv ${pmda_config_dir}/${domain}.* ${pmda_saved_config_dir}/
fi

# Create a new JSOM pmda config file and install it
cat > ${tmp}/config.json << EOF
{
    "directory_list" : [
	"${jsondata}"
    ]
}
EOF
$sudo cp ${tmp}/config.json ${pmda_config}

# Create a new pcp2json config file for use
cat > ${tmp}/pcp2json.config << EOF
[options]
header = no
daemonize = no
interval = 1
rank = 1

# Hot disk
[hot_disk]
prefix = hot_disk
diskutil = disk.dev.util
diskutil.formula = rate(disk.dev.avactive)
predicate = disk.dev.util
disk.dev.avactive = ,,
disk.dev.total_rawactive = ,,
disk.dev.aveq = ,,
disk.dev.total_bytes = ,,
disk.dev.blktotal = ,,

# Hot processor
[hot_processor]
prefix = hot_cpu
cpuburn = kernel.percpu.cpu.cpuburn
cpuburn.formula = rate(kernel.percpu.cpu.user) + rate(kernel.percpu.cpu.sys)
predicate = kernel.percpu.cpu.cpuburn
kernel.percpu.cpu.user = ,,
kernel.percpu.cpu.sys = ,,
EOF

# real QA test starts here
mkdir -p ${jsondata}
pmdajson_install

# Start pcp2json filtering to find hot disk with disk.dev.avactive.
pcp2json --config ${tmp}/pcp2json.config :hot_disk &
pmpred_disk_pid=$!

# Start pcp2json filtering to find hot processor running application code.
pcp2json --config ${tmp}/pcp2json.config :hot_processor &
pmpred_cpu_pid=$!

# select a disk and start reading stuff to generate load on disk
dev=/dev/`pmprobe -I disk.dev.read |awk -F \" '{print $2}'`
disk_load_script=${tmp}/disk_load
cat > ${disk_load_script} <<EOF
#!/bin/sh
dd if=$dev of=/dev/null &
echo \$! > ${tmp}/dd.pid
EOF
chmod +x ${disk_load_script}
$sudo "${disk_load_script}"

# generate a load on a processor
sh -c 'while :; do true; done' &
cpu_load_pid=$!

# Wait to make sure there is some load and the metrics exist
sleep 10

# Check to see if the metrics are there.
# sort to ensure consistent order of metrics
pminfo json |sort

# pmcd should have been started by the Install process - check
if pminfo -v json > $tmp.info 2> $tmp.err
then
    :
else
    echo "... failed! ... here is the Install log ..."
    cat $tmp.out
fi
cat $tmp.info $tmp.err

# start up pmlogger
cat > ${pmlogger_conf} << EOF
mandatory on 1 sec {
	json.hot_cpu.metrics.kernel_percpu_cpu_user
	json.hot_cpu.metrics.kernel_percpu_cpu_sys
	json.hot_disk.metrics.disk_dev_total_rawactive
	json.hot_disk.metrics.disk_dev_aveq
	json.hot_disk.metrics.disk_dev_total_bytes
	json.hot_disk.metrics.disk_dev_blktotal
}
EOF

pmlogger -c ${pmlogger_conf} -l ${pmlogger_log} -s 2 ${archive}

cd ${orig_dir}

_filter_pmlogger_log < ${pmlogger_log}
pmdumplog -dm ${archive} | _filter

# all done
pmdajson_remove
status=0
exit
