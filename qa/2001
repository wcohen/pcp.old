#!/bin/sh
# PCP QA Test No. 2002
# Test the pmpredicate command
#
# Copyright (c) 2017 Red Hat, Inc.  All Rights Reserved.
#

seq=`basename $0`
echo "QA output created by $seq"

# get standard environment, filters and checks
. ./common.product
. ./common.filter
. ./common.check
. ./common.python

python_path=`which $python`
pmda_path="$PCP_PMDAS_DIR/json"
pmda_script="${pmda_path}/pmdajson.python"
pmda_config="${pmda_path}/config.json"
ceph_script="${pmda_path}/generate_ceph_metadata"
qa_dir=`pwd`
json_qa_dir="${qa_dir}/json"
pmda_config_dir="${PCP_VAR_DIR}/config/pmda"
pmda_saved_config_dir="${pmda_config_dir}/pmdajson.$seq"

# test for-some-thing || _notrun No support for some-thing
test -f "$pmda_script" || _notrun "pmdajson not installed"
$python -c "from pcp import pmda" >/dev/null 2>&1
[ $? -eq 0 ] || _notrun "python pcp pmda module not installed"
$python -c "import jsonpointer" >/dev/null 2>&1
[ $? -eq 0 ] || _notrun "python jsonpointer module not installed"
$python -c "import six" >/dev/null 2>&1
[ $? -eq 0 ] || _notrun "python six module not installed"

_filter()
{
    sed \
	-e '/^\[[0-9]* bytes]/d' \
	-e "/pmcd\.pmlogger\./s/\[$logger_pid/\[LOGGER_PID/g" \
	-e "/pmcd\.pmlogger\./s/\"$logger_pid\"/\"LOGGER_PID\"/g" \
	-e '/pmcd\.pmlogger\.port/s/value .*/value PORT/' \
	-e '/pmcd\.pmlogger\.host/s/value ".*/value "HOST"/' \
	-e '/pmcd\.pmlogger\.archive/s/value ".*/value "PATH"/' \
	-e "/\"$logger_pid\"/s/$logger_pid/LOGGER_PID/g" \
    | $PCP_AWK_PROG '
$1 == "TIMESTAMP" && NF == 4	{ print "TIMESTAMP       0       OFFSET       OFFSET"; next }
				{ print }' \
    | src/hex2nbo
}

pmdajson_remove()
{
    echo
    echo "=== remove json agent ==="
    $sudo ./Remove >$tmp.out 2>&1
    _filter_pmda_remove <$tmp.out
}

pmdajson_install()
{
    # start from known starting points
    cd $PCP_PMDAS_DIR/json
    $sudo ./Remove >/dev/null 2>&1

    echo
    echo "=== json agent installation ==="
    $sudo ./Install </dev/null >$tmp.out 2>&1
    cat $tmp.out >>$here/$seq.full
    # Check json metrics have appeared ... X metrics and Y values
    _filter_pmda_install <$tmp.out \
    | sed \
        -e '/^Waiting for pmcd/s/\.\.\.[. ]*$/DOTS/' \
        -e 's/[0-9][0-9]* warnings, //' \
    | $PCP_AWK_PROG '
/Check json metrics have appeared/    { if ($7 >= 20 && $7 <= 80) $7 = "X"
                                        if ($10 >= 0 && $10 <= 80) $10 = "Y"
                                      }
                                      { print }'
}

_cleanup()
{
    cd $here
    if $_needclean; then
	_needclean=false
        _restore_config $PCP_PMCDCONF_PATH
	if [ -f ${pmda_config}.$seq ]; then
	    _restore_config ${pmda_config}
	fi

	# Remove the newly created indom cache files and restore any
	# old indom cache files.
	$sudo rm -f ${pmda_config_dir}/${domain}.*
	if [ -d ${pmda_saved_config_dir} ]; then
	    $sudo mv ${pmda_saved_config_dir}/* ${pmda_config_dir}/
	    $sudo rm -rf ${pmda_saved_config_dir}
	fi
	if [ -n "$pmpred_cpu_pid" ]; then
	    kill -TERM $pmpred_cpu_pid
	fi
	if [ -n "$pmpred_disk_pid" ]; then
	    kill -TERM $pmpred_disk_pid
	fi
	if [ -n "$disk_load_pid" ]; then
	    echo killing $disk_load_pid
	    $sudo kill -TERM $disk_load_pid
	fi
	if [ -n "$cpu_load_pid" ]; then
	    kill -TERM $cpu_load_pid
	fi
	if [ -n "$loger_pid" ]; then
	    kill -TERM $logger_pid
	fi
    fi
    $sudo rm -rf $tmp $tmp.*
}
trap "_cleanup; exit \$status" 0 1 2 3 15

status=1	# failure is the default!
$sudo rm -rf $tmp $tmp.*
mkdir $tmp
chmod ugo+rwx $tmp
cd $tmp

_needclean=true

domain=137
test="$here/json"

# Copy the pmcd config file to restore state later.
_save_config $PCP_PMCDCONF_PATH

# Ditto for JSON pmda config.
if [ -f ${pmda_config} ]; then
    _save_config ${pmda_config}
fi

# We want to get any JSON pmda indom cache files out of the way, so we
# start with a clean slate. We'll restore these at the end.
if [ -f "${pmda_config_dir}/${domain}.0" ]; then
    $sudo rm -rf ${pmda_saved_config_dir}
    $sudo mkdir ${pmda_saved_config_dir}
    $sudo mv ${pmda_config_dir}/${domain}.* ${pmda_saved_config_dir}/
fi

# Create a new JSOM pmda config file and install it
cat > ${tmp}/config.json << EOF
{
    "directory_list" : [
	"${tmp}"
    ]
}
EOF
$sudo cp ${tmp}/config.json ${pmda_config}


# real QA test starts here

# Start pmpredicate to find hot disk with disk.dev.avactive.
pmpredicate -t 1 -r 1 -j hot_disk -f disk.dev.avactive -m disk.dev.avactive -m disk.dev.aveq  -m disk.dev.total_rawactive -m disk.dev.blktotal -m disk.dev.total_bytes -d ${tmp}/${seq}disk &
pmpred_disk_pid=$!

# Start pmpredicate to find hot processor running application code.
pmpredicate -t 1 -r 1 -j hot_cpu -f kernel.percpu.cpu.user -m kernel.percpu.cpu.user -m kernel.percpu.cpu.sys -d ${tmp}/${seq}cpu &
pmpred_cpu_pid=$!

# select a disk and start reading stuff to generate load on disk
dev=/dev/`pmprobe -I disk.dev.read |awk -F \" '{print $2}'`
($sudo dd if=$dev of=/dev/null) &
disk_load_pid=$!
echo $disk_load_pid

# generate a load on a processor
sh -c 'while :; do true; done' &
cpu_load_pid=$!

sleep 10
pmdajson_install

# there may be a race if the pmda has a bit of a slow start ... pause
sleep 10

# Check to see if the metrics are there.
pminfo json

# pmcd should have been started by the Install process - check
if pminfo -v json > $tmp.info 2> $tmp.err
then
    :
else
    echo "... failed! ... here is the Install log ..."
    cat $tmp.out
fi
cat $tmp.info $tmp.err

# start up pmlogger
cat > $tmp.config << EOF
mandatory on 1 sec {
	json.hot_cpu.metrics.kernel_percpu_cpu_user
	json.hot_cpu.metrics.kernel_percpu_cpu_sys
	json.hot_disk.metrics.disk_dev_total_rawactive
	json.hot_disk.metrics.disk_dev_aveq
	json.hot_disk.metrics.disk_dev_total_bytes
	json.hot_disk.metrics.disk_dev_blktotal
}
EOF

pmlogger -c $tmp.config -l $tmp.log -s 3 $tmp &
logger_pid=$!

_filter_pmlogger_log <$tmp.log
pmdumplog -a $tmp | _filter_pmdumplog | _filter

# all done
pmdajson_remove
status=0
exit
